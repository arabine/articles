{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1036\deflangfe1036{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f32\froman\fcharset238\fprq2 Times New Roman CE;}{\f33\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f35\froman\fcharset161\fprq2 Times New Roman Greek;}{\f36\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f37\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f38\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f39\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f48\fmodern\fcharset238\fprq1 Courier New CE;}
{\f49\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f51\fmodern\fcharset161\fprq1 Courier New Greek;}{\f52\fmodern\fcharset162\fprq1 Courier New Tur;}{\f53\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f54\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f55\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 
\fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \snext15 Standard;}{\*\cs16 \additive \sbasedon10 hmtexte;}{\s17\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \f2\fs20\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 \sbasedon0 \snext17 
Plain Text;}}{\info{\title (((Magazine : PC Team 71)))}{\author Belegar}{\operator Belegar}{\creatim\yr2001\mo7\dy16\hr23\min33}{\revtim\yr2001\mo12\dy22\hr16\min23}{\version32}{\edmins2858}{\nofpages2}{\nofwords1377}{\nofchars7349}
{\*\company (c) Dwarf Corp.}{\nofcharsws8704}{\vern8249}}\paperw11906\paperh16838\margl1417\margr1417\margt1417\margb1417 
\deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1417\dgvorigin1417\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale117\viewzk2\pgbrdrhead\pgbrdrfoot\nolnhtadjtbl \fet0\sectd \linex0\headery708\footery708\colsx708\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}\pard\plain \s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20\lang1031\langfe1036\langnp1031 (((Magazine: PC Team 76)))
\par }{\fs20 (((Rubrique : Team Pratik)))
\par (((Sous Rubrique : \'e9lectronique)))
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {
\par }\pard\plain \s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20 (((titre))) TeamBot (4) \endash  Commande de moteurs
\par 
\par (((chapo)))
\par Commen\'e7ons notre robot par lui donner les moyens de se mouvoir. Nous allons \'e9tudier sur deux num\'e9ros une solution de commande de moteurs \'e0 la fois tr\'e8s r\'e9pandue et extr\'eamement performante.
\par 
\par (((texte)))
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20 Lors des pr\'e9c\'e9dents articles, nous nous sommes int\'e9ress\'e9s aux outils de d\'e9veloppements et 
\'e0 quelques g\'e9n\'e9ralit\'e9s sur la robotique. A pr\'e9sent, nous allons commencer s\'e9rieusement notre robot. La t\'e2che qui nous int\'e9resse ce mois ci concerne la partie motrice du robot. Il existe beaucoup de moyens pour faire mouvoir not
re engin. Nous souhaitons que celui-ci soit capable de rouler en avant et en arri\'e8re, ce qui impose deux sens de rotation. Nous voulons que le robot puisse tourner sur place ; la seule solution est de se munir de deux moteurs. A la mani\'e8
re d'un tank, le robot tournera en faisant fonctionner un moteur dans un sens et l'autre moteur dans le sens inverse. Notre commande doit donc \'eatre ind\'e9pendante pour chaque moteur. Enfin, il peut \'ea
tre salvateur de pouvoir faire varier la vitesse de rotation des moteurs. Ce cahier des charges est alors assez pr\'e9cis : nous prendrons deux moteurs \'e0 courant continu. L'\'e9lectronique du robot sera s\'e9par\'e9e en plusieurs parties. L'\'e9
lectronique de commande du moteur, que nous verrons le mois prochain, va utiliser des courants beaucoup plus importants que le reste des composants. Cette partie sera appel\'e9e "partie puissance" alors que l'\'e9lectronique faible-courant sera appel\'e9
e "partie commande". Pour diverses raisons, il est pr\'e9f\'e9rable de s\'e9parer physiquement ces deux parties. Seuls les signaux de commande seront transmis via des c\'e2bles idoines.
\par 
\par (((inter))) La partie puissance
\par Nous verrons plus en d\'e9tail cette partie dans le prochain Team Pratik. N\'e9anmoins, il est bon de conna\'eetre \'e0 peu pr\'e8s ce que nous allons commander. Chaque moteur se verra command\'e9 \'e0 l'aide de plusieurs transistors branch\'e9
s de telle mani\'e8re \'e0 ce qu'ils forment le fameux "pont en H". Ce montage sp\'e9cial est extr\'eamement usit\'e9 pour la commande de moteurs \'e0 courant continus car il permet toutes les possibilit\'e9s. Analysons le sch\'e9ma fonctionnel pr\'e9sent
\'e9 ci-contre. La carte de puissance sera compos\'e9e de deux ponts en H, un pour chaque moteur. Chaque pont en H poss\'e8de deux entr\'e9es de commandes. Un fil sera utiliser pour sp\'e9cifier le sens de rotation du moteur, le codage sera do
nc binaire. Le deuxi\'e8me fil sera utilis\'e9 pour commander les transistors de mani\'e8re \'e0
 modifier la vitesse de rotation du moteur. Ce signal particulier se nomme MLI pour "Modulation de Largeur d'Impulsion (PWM ou Pulse Width Modulation en anglais). Il est mis en \'9c
uvre dans le bloc fonctionnel FS1.1, que nous allons analyser tout de suite.
\par 
\par (((inter))) La MLI
\par Ce type de signal est, comme nous l'avons dit pr\'e9c\'e9demment, \'e9norm\'e9ment utilis\'e9 dans la commande de moteur. On le trouve aussi dans la gestion de capteurs ou d'\'e9crans vid\'e9os, pour faire varier le contraste par exemple et \'e9
galement dans les transmissions par infrarouge. Un signal de type MLI est relativement simple \'e0 comprendre. Il s'agit tout simplement d'un signal cr\'e9neau dont le rapport cyclique est variable. La cons\'e9
quence est que la valeur moyenne du signal peut \'eatre modifi\'e9e \'e0 volont\'e9. Regardons ensemble le chronogramme pr\'e9sent\'e9 ci-contre. Nous avons l\'e0 deux exemples de MLI. La fr\'e9quence du signal est fixe (ici 15kHz) et seul le temps \'e0
 l'\'e9tat haut change. On exprime la valeur d'une MLI en pourcentage : le temps pass\'e9 \'e0 l'\'e9tat haut divis\'e9 par la p\'e9riode du signal. Pour le chronogramme du haut, nous avons donc (50/67)*100 soit 75%, et 25% pour le deuxi\'e8
me chronogramme. Il existe plusieurs moyens pour g\'e9n\'e9rer un signal de cette forme. Tout d'abord, il est possible de le fabriquer avec des composants analogiques, \'e0 base d'amplificateurs op\'e9rationnels ou d'oscillateurs de type NE555. Ces m\'e9
thodes pr\'e9sentent l'avantage d'\'eatre peu on\'e9reuses, moins de deux euros en tout et pour tout. Malheureusement leur encombrement sur une carte est important et, plus que tout, leur commande est loin d'\'eatre \'e9
vidente. Rappelons que le cerveau central de notre robot devra envoyer des ordres \'e0 la partie commande moteur, d'o\'f9 la n\'e9cessit\'e9 de pouvoir modifier facilement la valeur de la MLI. Bien que plus ch\'e8re, notre solution \'e0 base de microcontr
\'f4leur 16F84 se r\'e9v\'e8lera fiable, fonctionnelle et parfaitement adapt\'e9e \'e0 nos besoins.
\par 
\par (((inter))) L'assembleur 16F84
\par Cela fait d\'e9j\'e0 quelques num\'e9ros que nous parlons de ce processeur. Nous vous invitons donc \'e0 vous reporter aux pr\'e9c\'e9dents articles, nous consid\'e9rons \'e0 pr\'e9sent que votre cha\'eene de d\'e9
veloppement est pleinement fonctionnelle. Penchons-nous un peu sur l'assembleur de cette c\'e9l\'e8bre famille de Microchip. La premi\'e8re page du datasheet (fourni sur le CD) nous annonce ses caract\'e9ristiques all\'e9
chantes : seulement 35 instructions \'e0 conna\'eetre, 1024 mots pour le programme et 68 octets de RAM, le tout cadenc\'e9 \'e0 la fr\'e9quence de 20MHz. Attention, le cycle (la fr\'e9quence de base) n'est pas de 20MHz mais de 5MHz car la fr\'e9
quence est divis\'e9e en interne. Enfin, une des caract\'e9ristiques les plus importantes est l'architecture RISC du processeur. Ainsi, chaque instruction se verra ex\'e9cut\'e9e en un seul cy
cle d'horloge, soit en 200ns. Ceci n'est pas vrai pour les instructions de branchement qui prennent deux cycles d'horloge. Cette architecture est parfaitement bien adapt\'e9e aux microcontr\'f4leurs car le programmeur peut ainsi calculer pr\'e9cis\'e9
ment la dur\'e9e de ses routines. Commen\'e7ons par jeter un coup d'\'9cil sur la grammaire de l'assembleur 16F84. Comme la majorit\'e9 des assembleurs, le code s'\'e9crit dans un fichier texte. Chaque ligne correspond \'e0 une instruction, et l'ex\'e9
cution du programme sera totalement s\'e9quentielle. L'illustration ci-contre montre un exemple de programme. L'\'e9criture d'un programme en assembleur doit s'\'e9crire de fa\'e7on rigoureuse. En effet, m\'eame si un programme bien indent\'e9
 est toujours plus facile \'e0 relire, l'assembleur impose une place particuli\'e8re pour chaque \'e9l\'e9ment. Ainsi, on distingue quatre colonnes. La premi\'e8re est r\'e9serv\'e9e aux \'e9tiquettes (ou aux labels), la seconde est r\'e9serv\'e9
e aux directives et aux mn\'e9moniques, la troisi\'e8me est utilis\'e9e pour les op\'e9randes et enfin la quatri\'e8me sert \'e0 placer des commentaires sur une seule ligne. Il faut s\'e9parer les diff\'e9rentes colonnes \'e0
 l'aide d'une tabulation pour bien indenter le code source. Les \'e9tiquettes servent \'e0 marquer une adresse pr\'e9cise dans le programme, pour faire des boucles par exemple. Les directives (en bleu sur l'image) sont destin\'e9es \'e0
 l'assembleur ; elles servent par exemple \'e0 indiquer \'e0 quelle adresse le code commence. Les mn\'e9moniques (en rouge) constituent le jeu d'instructions compris par le processeur. Les op\'e9randes (quand ils existent) sont constitu\'e9s de zones m
\'e9moires sp\'e9cifiques. Enfin, les commentaires (optionnels, en vert) permettent de d\'e9crire l'op\'e9ration effectu\'e9e. Bien s\'fbr, il est fortement recommand\'e9 d'en mettre le plus possible, surtout dans un code assembleur.
\par 
\par (((inter))) Programmation de la MLI
\par Le 16F84 est malheureusement d\'e9pourvu de fonctions embarqu\'e9es r\'e9serv\'e9es \'e0 la g\'e9n\'e9ration de MLI. Certains microcontr\'f4leurs en dispose ce qui est tr\'e8s pratique. Il est possible de cr\'e9
er facilement une MLI avec deux timers (des compteurs s'incr\'e9mentant \'e0 des instants pr\'e9cis) mais l\'e0 encore notre processeur n'en dispose que d'un seul. Qu'\'e0
 cela ne tienne, nous allons ruser. Vu que le composant ne fait que ce travail, nous allons utiliser le temps de traitement d'une instruction pour cr\'e9er des boucles d'attente tr\'e8s pr\'e9cises. Nous avons 200ns par instruction et nous d\'e9
sirons une fr\'e9quence ce 15KHz. Il faut donc que notre programme dure 333 cycles par p\'e9riode. Durant cette p\'e9riode, nous avons largement le temps de d\'e9coder les ordres, de les mettre en forme et de commander la MLI en cons\'e9
quence. Nous avons pr\'e9d\'e9fini cinq valeurs de MLI : 0%, 25%, 50%, 75% et 100%. Notre programme se chargera donc de faire varier le temps \'e0 l'\'e9tat haut selon la valeur de la MLI. Suivez l'organigramme avec le code source situ\'e9
 sur le CD et vous devriez \'eatre capable de tout comprendre.
\par 
\par (((inter))) Le mois prochain
\par Voil\'e0 de quoi vous occuper en attendant le prochain article qui portera enti\'e8rement sur la carte de puissance. Nous ferons le tour sur certaines th\'e9ories et nous ferons le lien avec l'article de ce mois-ci pour terminer la cha\'ee
ne de commande des moteurs. Bien s\'fbr, tous les sch\'e9mas et les sources seront disponibles pour vous aider.
\par 
\par }\pard\plain \s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20 (((signature)))
\par Anthony Rabine - arabine@programmationworld.com
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1036\langfe1036\cgrid\langnp1036\langfenp1036 {\fs20 (((images)))
\par elec1.tif : Le principe de notre commande de moteur.
\par elec2.tif : Deux exemples de signal dit "MLI".
\par elec3.tif : Un code source bien structur\'e9 facilite la relecture !
\par elec4.tif : L'oscilloscope, un outil indispensable pour l'\'e9lectronicien.
\par }}