<?xml version="1.0" encoding="ISO-8859-1"?>
<document type="Cours">
  <author>
    <name>Anthony Rabine</name>
    <email>arabine@programmationworld.com</email>
    <web-site>http://www.programmationworld.com</web-site>
  </author>
  <page>
    <title>L'arithmétique à virgule fixe</title>
    <introduction>Cet article servira à tous les développeurs sur plates-formes embarquées désireux d'optimiser leurs programmes. La représentation en vigule fixe permet de s'affranchir des types à firgules flottantes, les classiques float et double en langage C. Ceci étant, la repréentation en virgules fixes est totalement indépendante du langage utilisé.</introduction>
  </page>
  <section title="Motivations">
    <paragraph>Le programmeur dispose de deux grandes familles de types pour stocker ses variables : le type entier (int et ses variantes en C) et le type flottant (float, double). Le premier sert uniquement a stocker des grandeurs entières, c'est a dire sans virgules. Le deuxième type peut servir a stocker toutes sortes de valeurs y compris les nombres a virgules. La représentation d'un entier ne pose pas de problème en mémoire, il s'agit de données brutes codées au format binaire, en complément a deux lorsque la donnée est signée.</paragraph>
    <paragraph>Le format float est code en mémoire selon la norme IEEE 754. Le code contient un bit de signe, une mantisse et un exposant, le tout sur 32 bits (64 pour le type double). On appelle cette notation « flottante » car la virgule est placée selon la valeur de l'exposant. Cet exposant peut donc être modifie à tout moment lors d'un calcul.</paragraph>
    <paragraph>Dans un ordinateur de type PC, le processeur central (le x86) n'accepte que des données entières, c'est-à-dire que ses registres de calculs ne comprennent que des données entières. Pour effectuer des calculs sur des grandeurs fractionnaires, on lui a adjoint un coprocesseur arithmétique dédie : le x87. Ces deux processeurs, autrefois sépares physiquement sur la carte mère, cohabitent maintenant dans le même boîtier depuis le 486.</paragraph>
    <paragraph>Cependant, le cas du PC n'est pas légion dans le monde de l'électronique. Pour des raisons de coûts et de consommation, les équipements dits « embarqués « ne peuvent pas être équipes de coprocesseur arithmétique. C'était également le cas des premiers processeurs de bureaux. L'absence de tout processeur dédie dans le calcul des nombres a virgule est comble par un mécanisme d'émulation : tout le codage/décodage effectue en logique câblée par le coprocesseur arithmétique est remplacée par des librairies simulant le même comportement, toujours en respectant la norme IEEE 754 bien sur. Cette solution s'avère salvatrice pour le programmeur haut niveau car le mécanisme est totalement transparent : il peut programmer exactement de la même manière, qu'il possède ou nom un coprocesseur arithmétique. C'est le compilateur qui décidera qu'elle solution choisir selon la configuration matérielle de la cible (avec les configurations qui vont bien). Malheureusement, l'utilisation d'une émulation de coprocesseur arithmétique réduit considérablement les performances du logiciel. Cette solution est donc à proscrire dans les domaines temps réels ou le moindre cycle gagné est bon à prendre. La solution est alors de passer à une autre représentation des nombres à virgules : la représentation à virgule fixe.</paragraph>
    <paragraph>Nous vous conseillons de vous repporter aux cours précédents pour plus d'explications sur les bases et la représentation des nombres.</paragraph>
  </section>
  <section title="Principe et représentation">
    <paragraph>La représentation à virgule fixe permet de stocker des nombres à virgules dans des registres entiers. Dans le cas du type float, la virgule est positionnée dans la mantisse selon l'indication de l'exposant. Pour la virgule fixe, l'exposant est supprimé et la position de la virgule est contrôlée par le programmeur. Cette méthode n'est pas miraculeuse et nous pouvons déjà apercevoir le principal problème que nous rencontrerons : la gestion de cette virgule.</paragraph>
    <paragraph>Prenons le nombre positif suivant, codé en binaire sur 8 bits : 01100100&lt;br&gt;En placant la virgule a différents endroits, nous obtenons les valeurs suivantes :</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_1.png</link>
      <legend>Exemples de représentation de nombres en virgules fixes.</legend>
    </image>
    <paragraph>L'exposant, représentant le nombre de chiffres après la virgule, est noté Q dans la littérature. Cet exposant est virtuel car la mantisse est stockée dans un registre entier classique. Cependant, il est nécessaire de le connaître pour que le résultat ait le sens voulu, comme le montre le tableau ci-dessus.</paragraph>
    <paragraph>Dans le cas des nombres signés, la partie entière contiendra au moins un bit, le bit de signe. Si la partie entière contient plus d'un bit, on spécifie son nombre de la manière suivante :</paragraph>
    <code syntax="None">Q4.27 : 4 chiffres pour la partie entière, un bit de signe et 27 bits pour la partie décimale.</code>
    <paragraph>Soit de manière générale Qi.f (i comme int, f comme float)</paragraph>
    <paragraph>En traitement du signal, on n'utilise pratiquement que nombres compris entre -1 et 1. En effet, le résultat de la multiplication de deux nombres dans cet intervalle restera dans cet intervalle. Une multiplication de deux nombres de taille N bits donnera un résultat sur 2N bits. Avec des nombres compris entre -1 et 1, on pourra revenir a une taille de N bits moyennant une perte de précision. Néanmoins, on évite quand même l'augmentation rapide de la taille des résultats des calculs.</paragraph>
    <paragraph>On représente les nombres entre -1 et 1 sans spécifier la taille de la partie entière. Exemple : Q7, c'est 7 bits après la virgule et un bit de signe, situé avant la virgule. Par exemple : 1.0110100</paragraph>
    <paragraph>N'oubliez pas que la règle d'or en traitement de signal est de garder la plus grande précision possible durant toutes les phases d'un calcul.</paragraph>
  </section>
  <section title="Dynamique">
    <paragraph>Un nombre représenté en virgule fixe possède une dynamique particulière, différente des types classiques tels que le int ou le char en C. Prenons par exemple un nombre quelconque représenté en Q3.8 dans un registre 16 bits. Celui-ci aura la forme suivante :</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_2.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>S étant le bit de signe, propagé pour remplir le registre (sinon le nombre sera mal compris par le processeur). Nous rappelons que le nombre est codé en complément à deux. La dynamique sera donc :</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_3.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>Du minimum, soit -8. La valeur de ce registre vaut 0xF800.</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_4.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>. au maximum, soit 7.99609375. La valeur de ce registre vaut 0x07FF.&lt;br&gt;Nous rappelons que la partie décimale est codée en puissances de deux décroissantes (2-1, 2-2, .)</paragraph>
  </section>
  <section title="Overflow">
    <paragraph>L'overflow, ou dépassement, survient lorsque le nombre dépasse la dynamique de la représentation en virgule fixe. Ce phénomène peut survenir durant une série de calculs, des multiplications successives par exemple. Or, s'il y a dépassement, la valeur n'a plus aucun sens, tout du moins dans la représentation qui a été fixée. En théorie, il faudrait tester s'il y a ou non overflow après chaque calcul. Dans la pratique, ces tests se révèlent extrêmement gourmands en cycle processeurs, et chacun sait que ces cycles sont précieux dans les systèmes temps réels embarqués. Généralement, on ne va tester l'overflow qu'à certains endroits critiques du programme. Ailleurs, le programmeur doit maîtriser toutes les étapes des calculs. Cette fonctionnalité est d'ailleurs implantée au sein même de certains processeurs, a l'instar des DSP (Digital Signal Processors, des processeurs dédies au traitement du signal).</paragraph>
  </section>
  <section title="Saturation">
    <paragraph>Pour éviter que les calculs ne deviennent complètement aberrants lorsqu'un overflow survient, on procède a la saturation du résultat incriminé. La saturation consiste a fixer la donne a sa valeur la plus élevée ou la plus faible s'il s'agit d'un nombre négatif. Ce mécanisme est automatiquement réalisé par des processeurs de type DSP (Digital Signal Processors). Sur des processeurs à vocation générale, on ne trouve pas de tels mécanismes. Le test a effectuer est le suivant, en considérant val comme une valeur en fixed-point, et VAL_MAX/VAL_MIN sa dynamique :</paragraph>
    <code syntax="C">if(val &gt; VAL_MAX)
	val = VAL_MAX;
else if(val &lt; VAL_MIN)
	val = VAL_MIN;</code>
  </section>
  <section title="Arithmétique à virgule fixe">
    <paragraph>La virgule fixe permet de représenter des nombres à virgule sur des entiers. Les calculs s'effectueront donc entre nombres entiers, ce que tout processeur, même dépourvu de FPU (Floating Point Unit) est capable d'effectuer. Ceci étant, quelques précautions sont à prendre sur les formats Qi.f des opérandes et du résultat.</paragraph>
  </section>
  <section title="Addition et soustraction">
    <paragraph>Pour effectuer l'opération c = a + b, les opérandes a et b doivent être au même Qf (c'est à dire le même exposant). Le résultat c sera également de la même forme. Prenons un exemple : on souhaite additionner deux nombres en Q3.8 : </paragraph>
    <code syntax="None">00000011.10011010 soit 3 + 0.5 + 0.0625 + 0.03125 + 0.0078125 = 3.6015625 et
11111100.01010011 soit -4 + 0.25 + 0.0625 + 0.0078125 + 0.00390625 = -3.67578125</code>
    <paragraph>Le calcul avec les nombres décimaux donne -0.07421875. Procédons au calcul en binaire, c'est a dire comme le ferait un processeur :</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_5.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>soit -1 + 0.5 + 0.25 + 0.125 + 0.03125 + 0.015625 + 0.00390625 = -0.07421875</paragraph>
    <paragraph>On retrouve bien le même résultat, avec la virgule toujours placée au même endroit. Prenons maintenant deux autres nombres choisis pour provoquer un dépassement :</paragraph>
    <paragraph>A FAIRE</paragraph>
  </section>
  <section title="Multiplication">
    <paragraph>La multiplication d'un nombre Qi.f avec un nombre Qi'.f' donnera un résultat de taille Qi+i'.f+f'. Attention cependant, le résultat contiendra deux bits de signe. Le bit le plus proche de la virgule sera le vrai bit de signe, a conserver, et le deuxième bit de signe, situe a gauche du premier, est appelé bit étendu. Il est mis de cote dans la prise en compte du résultat. Voici quelques exemples pour éclaircir tout cela.</paragraph>
    <paragraph>&lt;b&gt;&lt;font size="+1"&gt;Multiplication par une constante&lt;/font&gt;&lt;/b&gt;</paragraph>
    <paragraph>A FAIRE</paragraph>
    <paragraph>&lt;b&gt;&lt;font size="+1"&gt;Multiplication par deux nombres à virgules fixes&lt;/font&gt;&lt;/b&gt;</paragraph>
    <paragraph>Nous allons prendre deux nombres en Q4 de façon a simplifier le calcul :</paragraph>
    <code syntax="None">0.1010 (0.5 + 0.125 = 0.625) 
1.0011 ( -1 + 0.125 + 0.0625 = -0.8125)</code>
    <paragraph>La multiplication avec les nombres en base 10 donne -0.5078125. La multiplication de deux Q4 donne un Q8 avec deux bits de signe.</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_6.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>On procède ici au calcul de la multiplication exactement comme avec les nombres décimaux, en prenant garde toutefois a quelques petites particularités. Le résultat final sera donc une somme de produits partiels. Calculons ces produits partiels, sans se préoccuper de la position de la virgule :</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_7.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>Arrêtons nous la pour le moment. Le dernier produit partiel est un peu plus délicat a calculer car le bit après la virgule représente de bit de signe : dans notre cas il vaut -1. Il faut donc prendre le complément a deux de 01010, soit 10110.&lt;br&gt;Additionnons tous ces produits partiels avec les décalages.</paragraph>
    <image>
      <link type="img">E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_8.png</link>
      <legend>
      </legend>
    </image>
    <paragraph>on place correctement la virgule (résultat en Q8) et on calcule le résultat en décimal :</paragraph>
    <code syntax="None">-1+0.25+0.125+0.0625+0.03125+0.015625+0.0078125 = -0.5078125</code>
    <paragraph>Le compte est bon, nous avons le même résultat que le calcul en décimal.</paragraph>
  </section>
  <section title="Division">
    <paragraph>La division suit la même logique que la multiplication. Néanmoins, nous ne vous conseillons de transformer vos divisions en multiplications car les divisions sont des opérations très gourmandes pour les processeurs. Certaines architectures, comme le coeur ARM, ne possèdent même aucun mécanisme matériel pour effectuer des divisions. Etant donné que cet article s'adresse en priorité à des applications embarquées nous ne nous épancherons pas plus sur cet opérateur.</paragraph>
  </section>
  <section title="Changement de précision">
    <paragraph>A FAIRE : décalages&lt;br&gt;</paragraph>
  </section>
  <section title="Implémentation en langage C">
    <paragraph>La grande puissance de la représentation en virgule fixe est sa facilité de mise en ouvre en programmation, aussi bien en assembleur que dans des langages de plus haut niveau. En effet, le changement de résolution (passage d'un Q32 en Q15 par exemple) s'obtient par un simple décalage.</paragraph>
    <paragraph>Prenons un premier exemple pour se familiariser avec la virgule fixe. Il s'agit de calculer le périmètre d'un cercle. Nous allons utiliser des macros pour faciliter le passage entre le domaine de la virgule fixe sur entier et le domaine de la virgule flottante (double, float).</paragraph>
    <note title="Remarque" img="http://www.programmationworld.com/site/images/rmq.gif">Les macros se chargent de prendre la partie entière d'un nombre a virgule flottante. Ce nombre est décalé pour pouvoir stocker Qf valeurs après la virgule. Attention, il s'agit d'un décalage binaire (avec les bits), et non décimal ! (un multiple de 10)</note>
    <code syntax="None">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define TOFIX(d, q) ((int)( (d)*(double)(1&lt;&lt;(q)) ))
#define TODBL(a, q) ( (double)(a)/(double)(1&lt;&lt;(q)) )

#define pi 3.14159265358979323846

int main(void)
{

  double out;
  int r=6, p, fix_pi;

  // calcul du perimètre d'un cercle, p = 2*pi*r

  fix_pi = TOFIX(pi, 14);      // Q2.14... plus un bit de signe !
  p = fix_pi * 2;              // Q2.14 + Q2.14 = Q3.14 : possibilité d'overflow
  p = p * 6;              // Q3.14 * 6 = Q6.14 car maxi==6*7=42, tient sur 6 bits

  // a partir de la, on sait que l'on tient toujours sur 32 bits (6+14&lt;32) 
  // donc c'est bon...
  out = TODBL(p, 14);   // pour verifier
  printf("%lf\n",out);  // en double
  printf("0x%X\n",p);   // en fixpoint... calculez, en placant la virgule en Q14

  return 0;
}
</code>
    <paragraph>Ce programme donne le résultat suivant :</paragraph>
    <paragraph>37.698486&lt;br&gt;0x96CB4</paragraph>
    <paragraph>Les macros ci-dessus peuvent également servir à générer des tables de sinus ou de cosinus en statique, c'est à dire situés en ROM une fois compilés.</paragraph>
    <code syntax="C">/**
 * sinus est compris entre -1 et +1, on va le stocker en Q15 (arbitraire)
 */
void gen_sin_tab()
{
	FILE *out;
	int i;
	int nb_points=100;   // nombre de points à prendre dans le sinus

	out = fopen("sin_table.h", "wt");

	fprintf(out, "// Lookup-table de sinus en Q15\n");
	fprintf(out,"static int sin_table[] = {\n");


	for(i=0;i&lt;nb_points;i++)
	{
		fprintf(out, "%d,", TOFIX(sin(i*2*pi/nb_points),15));
		if(!(i%10))
			fprintf(out,"\n");
	}

	fprintf(out,"};\n");
	fclose(out);
}</code>
    <paragraph>Ce programme génère la table suivante :</paragraph>
    <code syntax="None">// Lookup-table de sinus en Q15
static int sin_table[] = {
0,
2057,4106,6140,8149,10125,12062,13951,15786,17557,19260,
20887,22431,23886,25248,26509,27666,28714,29649,30466,31164,
31738,32187,32509,32703,32768,32703,32509,32187,31738,31164,
30466,29649,28714,27666,26509,25248,23886,22431,20887,19260,
17557,15786,13951,12062,10125,8149,6140,4106,2057,0,
-2057,-4106,-6140,-8149,-10125,-12062,-13951,-15786,-17557,-19260,
-20887,-22431,-23886,-25248,-26509,-27666,-28714,-29649,-30466,-31164,
-31738,-32187,-32509,-32703,-32768,-32703,-32509,-32187,-31738,-31164,
-30466,-29649,-28714,-27666,-26509,-25248,-23886,-22431,-20887,-19260,
-17557,-15786,-13951,-12062,-10125,-8149,-6140,-4106,-2057,};</code>
    <paragraph>Bien entendu, la précision est ici totalement arbitraire. En fait, deux précisions sont arbitraires : la précision en virgule fixe de la représentation choisie (ici Q15) et la précision de la table de sinus, limitée ici à 100 points. Ces deux paramètres dépenderont de l'application et de la précision souhaitée par les autres parties du logiciel. Pour des applications embarquées utilisant une visualisation sur écran LCD, la précision peut être choisie en fonction de la résolution de l'écran par exemple.</paragraph>
    <paragraph>Exemple d'utilisation : nous allons nous servir de notre table pour calculer rapidement ... Afin de rendre le programme un peu plus précis, nous allons prendre 360 échantillons ce qui donne une résolution du degré.</paragraph>
  </section>
</document>