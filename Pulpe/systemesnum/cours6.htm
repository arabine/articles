<link title="Style" href="Css/stylesheet.css" type="text/css" rel="stylesheet" /><table class="main" width="99%"><tr><td class="titleprincipal">L'arithmétique à virgule fixe<br /></td></tr><tr><td><br /><br /><br /><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Cet article servira à tous les développeurs sur plates-formes embarquées désireux d'optimiser leurs programmes. La représentation en vigule fixe permet de s'affranchir des types à firgules flottantes, les classiques float et double en langage C. Ceci étant, la repréentation en virgules fixes est totalement indépendante du langage utilisé.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_1"></a>Motivations</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Le programmeur dispose de deux grandes familles de types pour stocker ses variables : le type entier (int et ses variantes en C) et le type flottant (float, double). Le premier sert uniquement a stocker des grandeurs entières, c'est a dire sans virgules. Le deuxième type peut servir a stocker toutes sortes de valeurs y compris les nombres a virgules. La représentation d'un entier ne pose pas de problème en mémoire, il s'agit de données brutes codées au format binaire, en complément a deux lorsque la donnée est signée.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Le format float est code en mémoire selon la norme IEEE 754. Le code contient un bit de signe, une mantisse et un exposant, le tout sur 32 bits (64 pour le type double). On appelle cette notation « flottante » car la virgule est placée selon la valeur de l'exposant. Cet exposant peut donc être modifie à tout moment lors d'un calcul.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Dans un ordinateur de type PC, le processeur central (le x86) n'accepte que des données entières, c'est-à-dire que ses registres de calculs ne comprennent que des données entières. Pour effectuer des calculs sur des grandeurs fractionnaires, on lui a adjoint un coprocesseur arithmétique dédie : le x87. Ces deux processeurs, autrefois sépares physiquement sur la carte mère, cohabitent maintenant dans le même boîtier depuis le 486.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Cependant, le cas du PC n'est pas légion dans le monde de l'électronique. Pour des raisons de coûts et de consommation, les équipements dits « embarqués « ne peuvent pas être équipes de coprocesseur arithmétique. C'était également le cas des premiers processeurs de bureaux. L'absence de tout processeur dédie dans le calcul des nombres a virgule est comble par un mécanisme d'émulation : tout le codage/décodage effectue en logique câblée par le coprocesseur arithmétique est remplacée par des librairies simulant le même comportement, toujours en respectant la norme IEEE 754 bien sur. Cette solution s'avère salvatrice pour le programmeur haut niveau car le mécanisme est totalement transparent : il peut programmer exactement de la même manière, qu'il possède ou nom un coprocesseur arithmétique. C'est le compilateur qui décidera qu'elle solution choisir selon la configuration matérielle de la cible (avec les configurations qui vont bien). Malheureusement, l'utilisation d'une émulation de coprocesseur arithmétique réduit considérablement les performances du logiciel. Cette solution est donc à proscrire dans les domaines temps réels ou le moindre cycle gagné est bon à prendre. La solution est alors de passer à une autre représentation des nombres à virgules : la représentation à virgule fixe.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Nous vous conseillons de vous repporter aux cours précédents pour plus d'explications sur les bases et la représentation des nombres.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_2"></a>Principe et représentation</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La représentation à virgule fixe permet de stocker des nombres à virgules dans des registres entiers. Dans le cas du type float, la virgule est positionnée dans la mantisse selon l'indication de l'exposant. Pour la virgule fixe, l'exposant est supprimé et la position de la virgule est contrôlée par le programmeur. Cette méthode n'est pas miraculeuse et nous pouvons déjà apercevoir le principal problème que nous rencontrerons : la gestion de cette virgule.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Prenons le nombre positif suivant, codé en binaire sur 8 bits : 01100100&lt;br&gt;En placant la virgule a différents endroits, nous obtenons les valeurs suivantes :</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_1.png"></img><br /><b><u>Exemples de représentation de nombres en virgules fixes.</u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;L'exposant, représentant le nombre de chiffres après la virgule, est noté Q dans la littérature. Cet exposant est virtuel car la mantisse est stockée dans un registre entier classique. Cependant, il est nécessaire de le connaître pour que le résultat ait le sens voulu, comme le montre le tableau ci-dessus.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Dans le cas des nombres signés, la partie entière contiendra au moins un bit, le bit de signe. Si la partie entière contient plus d'un bit, on spécifie son nombre de la manière suivante :</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>Q4.27 : 4 chiffres pour la partie entière, un bit de signe et 27 bits pour la partie décimale.</pre></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Soit de manière générale Qi.f (i comme int, f comme float)</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;En traitement du signal, on n'utilise pratiquement que nombres compris entre -1 et 1. En effet, le résultat de la multiplication de deux nombres dans cet intervalle restera dans cet intervalle. Une multiplication de deux nombres de taille N bits donnera un résultat sur 2N bits. Avec des nombres compris entre -1 et 1, on pourra revenir a une taille de N bits moyennant une perte de précision. Néanmoins, on évite quand même l'augmentation rapide de la taille des résultats des calculs.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;On représente les nombres entre -1 et 1 sans spécifier la taille de la partie entière. Exemple : Q7, c'est 7 bits après la virgule et un bit de signe, situé avant la virgule. Par exemple : 1.0110100</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;N'oubliez pas que la règle d'or en traitement de signal est de garder la plus grande précision possible durant toutes les phases d'un calcul.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_3"></a>Dynamique</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Un nombre représenté en virgule fixe possède une dynamique particulière, différente des types classiques tels que le int ou le char en C. Prenons par exemple un nombre quelconque représenté en Q3.8 dans un registre 16 bits. Celui-ci aura la forme suivante :</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_2.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;S étant le bit de signe, propagé pour remplir le registre (sinon le nombre sera mal compris par le processeur). Nous rappelons que le nombre est codé en complément à deux. La dynamique sera donc :</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_3.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Du minimum, soit -8. La valeur de ce registre vaut 0xF800.</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_4.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;. au maximum, soit 7.99609375. La valeur de ce registre vaut 0x07FF.&lt;br&gt;Nous rappelons que la partie décimale est codée en puissances de deux décroissantes (2-1, 2-2, .)</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_4"></a>Overflow</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;L'overflow, ou dépassement, survient lorsque le nombre dépasse la dynamique de la représentation en virgule fixe. Ce phénomène peut survenir durant une série de calculs, des multiplications successives par exemple. Or, s'il y a dépassement, la valeur n'a plus aucun sens, tout du moins dans la représentation qui a été fixée. En théorie, il faudrait tester s'il y a ou non overflow après chaque calcul. Dans la pratique, ces tests se révèlent extrêmement gourmands en cycle processeurs, et chacun sait que ces cycles sont précieux dans les systèmes temps réels embarqués. Généralement, on ne va tester l'overflow qu'à certains endroits critiques du programme. Ailleurs, le programmeur doit maîtriser toutes les étapes des calculs. Cette fonctionnalité est d'ailleurs implantée au sein même de certains processeurs, a l'instar des DSP (Digital Signal Processors, des processeurs dédies au traitement du signal).</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_5"></a>Saturation</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Pour éviter que les calculs ne deviennent complètement aberrants lorsqu'un overflow survient, on procède a la saturation du résultat incriminé. La saturation consiste a fixer la donne a sa valeur la plus élevée ou la plus faible s'il s'agit d'un nombre négatif. Ce mécanisme est automatiquement réalisé par des processeurs de type DSP (Digital Signal Processors). Sur des processeurs à vocation générale, on ne trouve pas de tels mécanismes. Le test a effectuer est le suivant, en considérant val comme une valeur en fixed-point, et VAL_MAX/VAL_MIN sa dynamique :</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>if(val &gt; VAL_MAX)
	val = VAL_MAX;
else if(val &lt; VAL_MIN)
	val = VAL_MIN;</pre></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_6"></a>Arithmétique à virgule fixe</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La virgule fixe permet de représenter des nombres à virgule sur des entiers. Les calculs s'effectueront donc entre nombres entiers, ce que tout processeur, même dépourvu de FPU (Floating Point Unit) est capable d'effectuer. Ceci étant, quelques précautions sont à prendre sur les formats Qi.f des opérandes et du résultat.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_7"></a>Addition et soustraction</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Pour effectuer l'opération c = a + b, les opérandes a et b doivent être au même Qf (c'est à dire le même exposant). Le résultat c sera également de la même forme. Prenons un exemple : on souhaite additionner deux nombres en Q3.8 : </div></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>00000011.10011010 soit 3 + 0.5 + 0.0625 + 0.03125 + 0.0078125 = 3.6015625 et
11111100.01010011 soit -4 + 0.25 + 0.0625 + 0.0078125 + 0.00390625 = -3.67578125</pre></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Le calcul avec les nombres décimaux donne -0.07421875. Procédons au calcul en binaire, c'est a dire comme le ferait un processeur :</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_5.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;soit -1 + 0.5 + 0.25 + 0.125 + 0.03125 + 0.015625 + 0.00390625 = -0.07421875</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;On retrouve bien le même résultat, avec la virgule toujours placée au même endroit. Prenons maintenant deux autres nombres choisis pour provoquer un dépassement :</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A FAIRE</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_8"></a>Multiplication</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La multiplication d'un nombre Qi.f avec un nombre Qi'.f' donnera un résultat de taille Qi+i'.f+f'. Attention cependant, le résultat contiendra deux bits de signe. Le bit le plus proche de la virgule sera le vrai bit de signe, a conserver, et le deuxième bit de signe, situe a gauche du premier, est appelé bit étendu. Il est mis de cote dans la prise en compte du résultat. Voici quelques exemples pour éclaircir tout cela.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;b&gt;&lt;font size="+1"&gt;Multiplication par une constante&lt;/font&gt;&lt;/b&gt;</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A FAIRE</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;b&gt;&lt;font size="+1"&gt;Multiplication par deux nombres à virgules fixes&lt;/font&gt;&lt;/b&gt;</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Nous allons prendre deux nombres en Q4 de façon a simplifier le calcul :</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>0.1010 (0.5 + 0.125 = 0.625) 
1.0011 ( -1 + 0.125 + 0.0625 = -0.8125)</pre></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La multiplication avec les nombres en base 10 donne -0.5078125. La multiplication de deux Q4 donne un Q8 avec deux bits de signe.</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_6.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;On procède ici au calcul de la multiplication exactement comme avec les nombres décimaux, en prenant garde toutefois a quelques petites particularités. Le résultat final sera donc une somme de produits partiels. Calculons ces produits partiels, sans se préoccuper de la position de la virgule :</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_7.png"></img><br /><b><u></u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Arrêtons nous la pour le moment. Le dernier produit partiel est un peu plus délicat a calculer car le bit après la virgule représente de bit de signe : dans notre cas il vaut -1. Il faut donc prendre le complément a deux de 01010, soit 10110.&lt;br&gt;Additionnons tous ces produits partiels avec les décalages.</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><img src="E:\Documents\Articles\Cours Progworld\systemesnum\images\cours6_8.png"></img><br /><b><u>Légende par défaut</u></b></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;on place correctement la virgule (résultat en Q8) et on calcule le résultat en décimal :</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>-1+0.25+0.125+0.0625+0.03125+0.015625+0.0078125 = -0.5078125</pre></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Le compte est bon, nous avons le même résultat que le calcul en décimal.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_9"></a>Division</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La division suit la même logique que la multiplication. Néanmoins, nous ne vous conseillons de transformer vos divisions en multiplications car les divisions sont des opérations très gourmandes pour les processeurs. Certaines architectures, comme le coeur ARM, ne possèdent même aucun mécanisme matériel pour effectuer des divisions. Etant donné que cet article s'adresse en priorité à des applications embarquées nous ne nous épancherons pas plus sur cet opérateur.</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_10"></a>Changement de précision</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A FAIRE : décalages&lt;br&gt;</div></td></tr><tr><td><br /><br /></td></tr><tr><td class="title"><a name="_topic_11"></a>Implémentation en langage C</td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;La grande puissance de la représentation en virgule fixe est sa facilité de mise en ouvre en programmation, aussi bien en assembleur que dans des langages de plus haut niveau. En effet, le changement de résolution (passage d'un Q32 en Q15 par exemple) s'obtient par un simple décalage.</div></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Prenons un premier exemple pour se familiariser avec la virgule fixe. Il s'agit de calculer le périmètre d'un cercle. Nous allons utiliser des macros pour faciliter le passage entre le domaine de la virgule fixe sur entier et le domaine de la virgule flottante (double, float).</div></td></tr><tr><td><br /><br /></td></tr><tr><td align="center"><table border="0" width="70%" cellborder="0" cellpadding="0" cellspacing="0"><tr><td class="notetitle" width="32"><img src="http://www.programmationworld.com/site/images/rmq.gif"></img></td><td class="notetitle" valign="middle">
                  Remarque<br /></td></tr><tr><td class="note" colspan="2">Les macros se chargent de prendre la partie entière d'un nombre a virgule flottante. Ce nombre est décalé pour pouvoir stocker Qf valeurs après la virgule. Attention, il s'agit d'un décalage binaire (avec les bits), et non décimal ! (un multiple de 10)</td></tr></table></td></tr><tr><td><br /><br /></td></tr><tr><td class="source"><pre>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define TOFIX(d, q) ((int)( (d)*(double)(1&lt;&lt;(q)) ))
#define TODBL(a, q) ( (double)(a)/(double)(1&lt;&lt;(q)) )

int main(void)
{

  double x = 3.14159265358979323846, out;
  int r=6, p, pi;

  // calcul du perimetre d'un cercle, p = 2*pi*r

  pi = TOFIX(x, 14);      // Q2.14... plus un bit de signe !
  p = pi * 2;                // Q2.14 + Q2.14 = Q3.14 : possibilite d'overflow
  p = p * 6;                 // Q3.14 * 6 = Q6.14 car maxi==6*7=42, tient sur 6 bits

  // a partir de la, on sait que l'on tient toujours sur 32 bits (6+14&lt;32) 
  // donc c'est bon...
  out = TODBL(p, 14);   // pour verifier
  
  printf("%lf\n",out);     // en double

  printf("0x%X\n",p);    // en fixpoint... calculez, en placant la virgule en Q14

  return 0;
}</pre></td></tr><tr><td><br /></td></tr><tr><td><div style="text-align:justify;">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ce programme donne le résultat suivant :</div></td></tr><tr><td><br /><br /></td></tr></table>