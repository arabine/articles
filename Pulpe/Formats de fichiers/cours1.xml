<?xml version="1.0" encoding="ISO-8859-1"?>
<document type="Cours">
  <author>
    <name>Anthony Anthony Anthony Anthony Anthony Anthony Anthony Anthony Anthony Sylvain Hellegouarch</name>
    <email>shellegouarch@programmationworld.com</email>
    <web-site>www.programmationworld.com</web-site>
  </author>
  <page>
    <title>Fichiers WAVE (.wav)</title>
    <introduction>Le format WAVE (Waveform) est un dérivé de la spécification RIFF (Resource Interchange File Format) de Microsoft dédiée au stockage de données multimédias. Ce format est libre d'utilisation et est sûrement le plus répendu parmis les nombreux formats de fichiers sons. Ce format est lisible sur la plupart des systèmes d'exploitation et par n'importe quel logiciel de traitement de son digne de ce nom. Le seul problème avec ce format est qu'il est évolutif et peut connaître de nombreuses formes (compressions audio etc.). Nous allons donc nous limiter pour le moment au format PCM (Pulse Code Modulation).</introduction>
  </page>
  <section title="Notes préalables">
    <paragraph>Le format WAVE est constitué d'un en-tête suivi des données (échantillons de son numérisé). Par défaut, les données sont ordonnées en little-endian ("petit-boutiste"), c'est à dire que l'octet de poids faible est stocké avant l'octet de poids fort. Les fichiers qui utilisent le format opposé, big-endian, possèdent l'identifiant RIFX à la place de RIFF (voir l'en-tête ci-dessous).</paragraph>
    <paragraph>Les labels (ou identifiants) en ASCII sont représentés en big-endian.</paragraph>
    <paragraph>Méthode pour calculer une taille, stockée sur 4 octets : par exemple si on lit 0x20 0x6B 0x00 0x00 cela donne :&lt;br&gt;0x20 + 0x6B*256 + 0x00*65536 +0x00*16777216 soit 32 + 107*256 = 27424&lt;br&gt;</paragraph>
  </section>
  <section title="L'en-tête">
    <paragraph>L'en-tête se décompose en trois sous partie, appelées "chunk" dans la littérature courante :&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;RIFF Chunk : l'en-tête propre au format général RIFF&lt;/li&gt;&lt;br&gt;&lt;li&gt;fmt Chunk : décrit le format du WAVE utilisé&lt;/li&gt;&lt;br&gt;&lt;li&gt;data Chunk : les données proprement dites&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Commençons par le premier Chunk qui correspond au format RIFF :&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font size="+2"&gt;RIFF Chunk&lt;/font&gt;&lt;/b&gt;</paragraph>
    <paragraph>&lt;table border="1" cellspacing="1" cellpadding="2" align="center" bgcolor="#FFFFCC" valign="top"&gt;&lt;tr align="center"&gt;&lt;td&gt;Offset (en octets)&lt;/td&gt;&lt;td&gt;Taille du champ (en octets)&lt;/td&gt;&lt;td&gt;Nom du champ&lt;/td&gt;&lt;td&gt;Détails&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;ChunkID&lt;/td&gt;&lt;td&gt;Type de fichier. Contient les lettres "RIFF" en ASCII (0x52494646)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;ChunkSize&lt;/td&gt;&lt;td&gt;Contient le nombre d'octets qui suivent, soit la taille du fichier moins 8 octets (c'est à dire sans compter ce champ et le champ précédent)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;Format&lt;/td&gt;&lt;td&gt;Type de fichier RIFF. Contient les lettres "WAVE" en ASCII (0x57415645)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</paragraph>
    <paragraph>Viennent ensuite les deux Chunks propres au format WAVE. Tout d'abord le Chunk fmt :&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font size="+2"&gt;fmt Chunk&lt;/font&gt;&lt;/b&gt;</paragraph>
    <paragraph>&lt;table border="1" cellspacing="1" cellpadding="2" align="center" bgcolor="#FFFFCC" valign="top"&gt;&lt;tr align="center"&gt;&lt;td&gt;Offset (en octets)&lt;/td&gt;&lt;td&gt;Taille du champ (en octets)&lt;/td&gt;&lt;td&gt;Nom du champ&lt;/td&gt;&lt;td&gt;Détails&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;fmtID&lt;/td&gt;&lt;td&gt;Contient les lettre "fmt " en ASCII (avec un espace après fmt, 0x666d7420)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;fmtSize&lt;/td&gt;&lt;td&gt;Taille du reste du Chunk, toujours 16 dans le cas du format PCM (en octets)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;20&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;AudioFormat&lt;/td&gt;&lt;td&gt;Toujours 1 dans le cas du format PCM. D'autres valeurs indiquent des formats de compression&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;22&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;NumChannels&lt;/td&gt;&lt;td&gt;Mono = 1, Stéréo = 2&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;24&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;SampleRate&lt;/td&gt;&lt;td&gt;Fréquence d'échantillonnage (en Hz) : 8000, 11025, 22050, 44100 etc. &lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;28&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;avgBytesPerSec&lt;/td&gt;&lt;td&gt;Taux de transfert nécessaire, en octets par seconde. Égal à : SampleRate * NumChannels * BitsPerSample/8&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;BlockAlign&lt;/td&gt;&lt;td&gt;Nombre d'octets par échantillon. Égal à : NumChannels * BitsPerSample/8&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;34&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;BitsPerSample&lt;/td&gt;&lt;td&gt;Nombre de bits par échantillon.&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;36&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;ExtraParamSize&lt;/td&gt;&lt;td&gt;Taille des paramètres supplémentaires. Ce champ &lt;b&gt;N'EXISTE PAS&lt;/b&gt; dans le cas du PCM&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</paragraph>
    <paragraph>Et le Chunk dédié aux données audio :&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font size="+2"&gt;data Chunk&lt;/font&gt;&lt;/b&gt;</paragraph>
    <paragraph>&lt;table border="1" align="center" bgcolor="#FFFFCC" &gt;&lt;tr align="center"&gt;&lt;td&gt;Offset (en octets)&lt;/td&gt;&lt;td&gt;Taille du champ (en octets)&lt;/td&gt;&lt;td&gt;Nom du champ&lt;/td&gt;&lt;td&gt;Détails&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;36&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;dataChunk&lt;/td&gt;&lt;td&gt;Contient les lettres "data" en ASCII (0x64617461)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;40&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;dataSize&lt;/td&gt;&lt;td&gt;Nombre d'octets de données à suivre (taille des données en octets)&lt;/td&gt;&lt;/tr&gt;&lt;tr align="center"&gt;&lt;td&gt;44&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;Data&lt;/td&gt;&lt;td&gt;Données audio (voir section suivante pour l'explication du rangement)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</paragraph>
  </section>
  <section title="Les données">
    <paragraph>Les échantillons sont rangés les uns après les autres, dans l'ordre temporel. Le contenu d'un échantillon varie selon le format du fichier. Dans le cas de la stéréo, la voie de gauche est d'abord disponible puis suit la voie de droite.</paragraph>
    <paragraph>Dans le cas d'échantillons 8-bit, les données sont en octets non signés (unsigned char). Les valeurs allant de 0 à 255, avec le zéro situé à 0x80 = 128.&lt;br&gt;Dans le cas d'échantillons 16-bit, les données sont codées en complément à deux (signed short), les valeurs allant de  -32768 à 32767.</paragraph>
    <paragraph>Chaque échantillon se termine sur une adresse paire.</paragraph>
    <paragraph>Voici deux exemples de données :</paragraph>
    <image>
      <link type="img">F:\Documents\Articles\Cours Progworld\Formats de fichiers\images\8bitmono.png</link>
      <legend>Exemple de données, 8-bit mono</legend>
    </image>
    <image>
      <link type="img">F:\Documents\Articles\Cours Progworld\Formats de fichiers\images\16bitstereo.png</link>
      <legend>Exemple de données, 16-bit stéréo</legend>
    </image>
  </section>
  <section title="Librairie">
    <paragraph>La librairie disponible ci-dessous se présente sous la forme d'une classe C++. La conversion vers d'autres langages est assez aisée. Cette classe a été compilée avec succès sous Windows avec VC++ 6.0 et sous Linux avec g++.&lt;br&gt;&lt;a href="downloads/CWaveFile.zip"&gt;CWaveFile.zip&lt;/a&gt; : la librairie de lecture, 4,39 ko.</paragraph>
    <paragraph>&lt;br&gt;&lt;u&gt;Formats supportés :&lt;/u&gt;&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Microsoft Wave PCM mono, stéréo) 8 ou 16 bits.&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;u&gt;Améliorations possibles :&lt;/u&gt;&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Rajouter la possibilité d'écrire des fichiers WAVE&lt;/li&gt;&lt;br&gt;&lt;li&gt;Changer les fonctions C de lecture par les équivalents dans la librairie standard de C++&lt;/li&gt;&lt;br&gt;&lt;li&gt;Supporter des formats de compression&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</paragraph>
  </section>
</document>