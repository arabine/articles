<?xml version="1.0" encoding="ISO-8859-1"?>
<document type="Cours">
  <author>
    <name>Anthony Anthony Anthony Anthony Anthony Rabine</name>
    <email>arabine@programmationworld.com</email>
    <web-site>http://www.programmationworld.com</web-site>
  </author>
  <page>
    <title>Introduction : présentation du PIC 16F84</title>
    <introduction>Le 16F84 de la famille PIC de Microchip est sans doute le microcontrôleur le plus utilisé dans le monde. Son incroyable popularité vient de sa facilité de mise en oeuvre et la disposition d'un IDE complet de développement totalement gratuit : MPLAB. Ces deux produits réunis permettent de développer dans de très bonnes conditions et très rapidement. Dans ce cours, nous allons essentiellement faire un peu de théorie.</introduction>
  </page>
  <section title="Présentation du 16F84">
    <paragraph>Le microcontrôleur PIC16F84 sera notre principale cible dans ce cours et les cours qui suivront. Le succès de ce produit vient du fait qu'il possède de nombreuses qualités. Commençons par présenter le composant en lui même. Le PIC 16F84 est fabriqué par un seul fondeur, Microchip. Bien entendu, ce n'est nullement le seul composant disponible dans le catalogue du constructeur mais c'est la référence la plus utilisée dans le monde des microcontrôleurs. Microchip est très dynamique et conçoit sans cesse de nouvelles versions et de nouvelles familles. D'autres références méritent le détour, comme les petits 12C509 (microcontrôleurs à 8 broches sans quartz externes) ou encore les 16F87x pour le haut de la gamme. Microchip possède également des DSP ainsi que des mémoires de type 24Cxx à son catalogue.</paragraph>
    <paragraph>Microchip est appelé le fondeur, à l'instar d'AMD ou de Intel pour les processeurs PC. Toute la gamme des microcontrôleurs de Microchip est appelée PIC, qui signifie Peripheral Interface Controller. Se sont généralement des petits microcontrôleurs, bien que certaines versions sont très puissances et véloces. Cette famille PIC contient de très nombreuses références, il y en a vraiment pout tous les goûts. La référence 16F84 est certainement la référence la plus populaire, notamment grâce à son faible coup et à ses bonnes capacités.</paragraph>
    <paragraph>Revenons à la référence qui nous intéresse, le 16F84. La photo ci-dessous montre un boîtier DIP qui est la version la plus courante. (et la plus pratique pour l'électronicien amateur)&lt;br&gt;</paragraph>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\pic16f84.jpg</link>
      <legend>Le PIC16F84 en boîtier DIP à 18 broches.&lt;br&gt;</legend>
    </image>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\pic16f84_smd.gif</link>
      <legend>Et la version CMS. (Composant Monté en Surface)&lt;br&gt;</legend>
    </image>
    <paragraph>Le grand avantage du 16F84 est son faible emcombrement. Le petit boîtier de 18 broches est extrêmement pratique pour le placer sur une carte électronique. Bien sûr, le revers de la médaille est qu'il ne dispose que peu de ports d'entrées sorties. Ceci étant, le but du 16F84 n'est en aucun cas de concurrencer les gros microcontrôleurs à 64 broches. La cible du 16F84 est avant tout dédié aux petites applications (en taille physique) et fournit la puissance et la souplesse d'un microcontrôleur localement.&lt;br&gt;&lt;br&gt;Voyons maintenant son brochage. La figure ci-dessous est tirée du datasheet (documentation constructeur) indispensable pour le développement. Si ce n'est pas déjà fait, hâtez vous de le télécharger, il est disponible en bas de cette page.</paragraph>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\brochage.gif</link>
      <legend>Le brochage du PIC 16F84, tiré de sa documentation constructeur.&lt;br&gt;</legend>
    </image>
    <paragraph>Rappelons que la petite encoche (le demi cercle situé à l'extrémité du boîtier) sert à connaître l'orientation du composant. En regardant du dessus, la roche immédiatement à gauche de cette encoche est la broche numérotée 1. Cette règle est vraie pour la grande majorité des composants ayant ce type de boîtier.&lt;br&gt;&lt;br&gt;Toutes les broches de sont pas "utiles". Par "utiles" nous entendons "pas utilisables par le programmeur". Ces broches servent à faire fonctionner le circuit mais ne sont pas accessibles via la programmation. Entrent dans cette catégorie les broches suivantes :&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Les broches 5 et 14 qui servent à alimenter le circuit. Le &lt;b&gt;Vss&lt;/b&gt; représente la masse (0V) et le &lt;b&gt;Vdd&lt;/b&gt; représente le 5V.&lt;/li&gt;&lt;br&gt;&lt;li&gt;La broche 4, &lt;b&gt;MCLR&lt;/b&gt;. Cette broche a deux fonctions : d'une part elle sert de reset (RAZ, ou Remise À Zéro), c'est à dire pour relancer le &lt;br&gt;programme interne, et d'autre part d'indicateur de programmation (pour programmer la mémoire interne avec notre code). Nous parlerons de &lt;br&gt;cette dernière fonctionalité plus tard, mais sachez qu'elle ne nous concernera pas directement. Nous l'utiliserons principalement comme &lt;br&gt;broche de reset.&lt;/li&gt;&lt;br&gt;&lt;li&gt;Enfin, les broches 15 et 16 servent à connecter un &lt;b&gt;oscillateur&lt;/b&gt;. Celui-ci est indispensable au microcontrôleur car c'est ce qui fournit &lt;br&gt;l'horloge de cadencement pour faire avancer le programme. Bref, c'est comme dans un ordinateur, sa présence est indispensable et sa fréquence &lt;br&gt;bien choisie.&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Voilà, nous avons fait le tour des broches indispensables au fonctionnement du microcontrôleur. Il suffit de brancher 5 broches et le tour est joué, le microcontrôleur est fonctionnel. Voyons maintenant plus précisément l'utilité de ces broches et comment les brancher. Le schéma ci-dessous montre l'électronique minimale pour faire "tourner" le microcontrôleur. La LED n'est bien sûre &lt;b&gt;pas&lt;/b&gt; nécessaire mais nous l'utiliserons un peu plus tard.</paragraph>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\schema_minimal.jpg</link>
      <legend>Le 16F84 n'a besoin que peu de composants périphériques pour fonctionner.&lt;br&gt;</legend>
    </image>
    <paragraph>Le composant est représenté schématiquement à l'aide d'un logiciel de CAO. Dans l'image ci-dessus, les broches "non utiles" sont regroupées sur le côté gauche. Ce n'est &lt;b&gt;pas&lt;/b&gt; sa représentation réelle, mais un schéma de principe, le brochage réel étant visible sur l'image précédant celle-ci. La broche Vdd est reliée au 5V et la broche Vss à la masse, comme nous l'avons dit plus haut. La broche de Reset est active au niveau bas ; ceci se voit dans le nom de la broche car il est suivit d'un anti-slash. On voit également souvent un tiret-bas (underscore) pour signifier cette particularité. Dire que la broche est active au niveau bas signifie qu'un Reset a lieu lorsqiue l'on applique un zéro volt à cette broche. Pour éviter que le microcontrôleur ne se trouve perpétuellement dans cet état, nous forçons la broche au 5V ; notre programme pourra donc "tourner".&lt;br&gt;&lt;br&gt;&lt;b&gt;Note importante :&lt;/b&gt; Le PIC 16F84 possède une fonctionalité intéressante appelée "Power-on Reset". Cette fonction a pour but de provoquer un Reset du programme interne lors de la mise sous tension. Le microcontrôleur voit alors un front montant sur son alimentation de qui initialise le programme. Sur certains microcontrôleurs, cette fonctionalité n'existe pas. Il est donc recommendé de se contruire son propre circuit de "Poser-on Reset". Notons que Microchip préconise d'ajouter ce circuit au PIC16F84 lorsque la mise sous tension est très lente. Ce ciruit de Reset et constitué de deux composants passifs : une résistance et un condensateur branchés comme cela :</paragraph>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\schema_reset.jpg</link>
      <legend>Un schéma classique de reset automatique.&lt;br&gt;</legend>
    </image>
    <paragraph>Le fonctionnement est simple : au démarrage, le condensateur est déchargé et la broche MCLR est à zéro volts. À la mise sous tension, le condensateur se charge à la constante de temps RC jusqu'à atteindre 5V. Le microcontrôleur a donc reçu un signal de reset puis est bloqué en fonctionnement normal ad vitam eternam.</paragraph>
    <paragraph>&lt;font size="5" color="#0000FF"&gt;Les autres broches&lt;/font&gt;&lt;br&gt;&lt;br&gt;Les autres broches sont tout simplement celles laissées à la disposition du programmeur. Dans le cas du PIC16F84, toutes les broches sont bidirectionnelles. (fonctionnement en entrée/sortie) Certaines possède une fonction particulière, nous en repparlerons plus tard. Les broches d'entrées/sorties sont regroupées en deux ports : le port A et le port B. Le port B est un port classique à 8 bits, laissant l'opportunité d'interfacer le PIC à des périphériques standards. (avec un bus de données de 8 bits) Le port A est quant à lui un port de 5 bits. Enfin, notons que chaque broche des ports peut être individuellement configurée en tant qu'entrée ou sortie.</paragraph>
    <paragraph>La technologie des ports est un peu particulière. En effet, certaines broches possèdent des fonctions bien précises comme une sortie Timer, une entrée d'interruption etc. Le port B est configurable par logiciel ; suivant ce qui est connecté au port, le programmeur peut décider si la sortie possède une résistance de tirage ou non. Le port A est presque quasiment en technologie TTL, seule la broche RA4 est de type collecteur ouvert. Nous reviendrons sur ces notions quand le temps sera venu. Entre temps, nous vous renvoyons à la datasheet fournie ci dessous qui est on ne peut plus complète.</paragraph>
    <note title="Remarque" img="http://www.programmationworld.com/site/images/rmq.gif">&lt;b&gt;A retenir :&lt;/b&gt; Lors de la conception d'un schéma électronique à base de PIC16F84, et de manière générale à base de microcontrôleur, il faut toujours regarder le type de technologie des ports d'entrées/sorties. Certains périphériques ne s'accomodent que d'un et un seul type de port (TTL, collecteur ouvert, MOS etc.)</note>
    <paragraph>&lt;font size="5" color="#0000FF"&gt;L'oscillateur&lt;/font&gt;&lt;br&gt;&lt;br&gt;L'oscillateur est le coeur du microcontrôleur : c'est lui qui cadence le déroulement du programme. Un oscillateur doit fournir un signal carré périodique au microcontrôleur. Il est tout à fait envisageable de le cadencer le microcontrôleur avec un oscillateur créé de toute pièce mais dans la pratique il est plus performant d'utiliser un quartz. Un quartz se met à osciller lorsqu'il est sousmis à une différence de potentiel. La fréquence centrale du quartz est très précise et varie peu dans le temps. Pour la famille PIC, nous allons considérer plusieurs types d'oscillateurs :&lt;br&gt;&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;LP : se sont les oscillateurs basse fréquence, en dessous de 200KHz&lt;/li&gt;&lt;br&gt;&lt;li&gt;XT : les oscillateurs moyenne frénquence, entre 200KHz et 4MHz&lt;/li&gt;&lt;br&gt;&lt;li&gt;HS : les oscillateurs haute fréquence, entre 4MHz et 20MHz&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Ces indications sont importantes car on les retrouvera lorsque nous programmerons le PIC 16F84.</paragraph>
    <image>
      <link type="img">E:\Documents\Cours Progworld\pic\images\oscillateur.gif</link>
      <legend>Le PIC possède en interne le composant nécessaire à l'oscillation : un inverseur.&lt;br&gt;</legend>
    </image>
  </section>
  <section title="Alimentation 5V">
    <paragraph>L'alimentation du PIC 16F84 en 5V peut être une question posée par certains. Il y a plusieurs possibilités :&lt;br&gt;&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Acheter un transformateur secteur, si tant est qu'il possède une position 5V&lt;/li&gt;&lt;br&gt;&lt;li&gt;Se munir d'une alimentation de laboratoire. N'importe laquelle est capable de fournir au moins 5V&lt;/li&gt;&lt;br&gt;&lt;li&gt;Construire un 5V à l'aide de piles ou d'accumulateurs&lt;/li&gt;&lt;br&gt;&lt;li&gt;Utiliser n'importe quelle source supérieure à 8V et utiliser un régulateur de tension&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</paragraph>
    <paragraph>Nous allons utiliser cette dernière solution qui a le mérite d'être à la fois souple et très fiable. Le régulateur que nous allons utiliser est le 7805, régulateur extrêmement répendu. Vous n'aurez aucun de mal à le trouver dans toute boutique d'électronique. Voici le schéma typique de câblage :</paragraph>
    <image>
      <link type="img">F:\Documents\Cours Progworld\pic\images\alim7805.gif</link>
      <legend>Schéma classique de branchement d'un régulateur 7805.&lt;br&gt;</legend>
    </image>
    <paragraph>Examinons un peu le schéma.</paragraph>
    <paragraph>L'alimentation d'entrée provient de n'importe quelle source de tension continue. Cela peut être une batterie ou une alimentation secteur. Pour un 7805, la tension minimale d'entrée doit être d'au moins 8V. En règle générale, compter 3V au dessus du voltage de régulation. Pour un 7806, la tension d'entrée minimale sera donc de 9V, 15V pour un 7812 etc.</paragraph>
    <paragraph>Viens ensuite une diode de protection. Cette diode est optionnelle et évite simplement toute inversion de la polarité d'entrée.Il faut généralement prendre l'habitude de la placer car cela évite de griller tous les composants situés après le régulateur, d'autant plus que le coût d'une diode est vraiment négligeable. La diode utilisée est une 4001, diode standard de puissance capable de supporter de forts courant et tension.</paragraph>
    <paragraph>Enfin, le 7805 proprement dit. Vous trouverez en bas de cette page la documentation constructeur. Il existe différents boitiers. Les deux plus standards sont les TO92 (petit boîtier de la même forme que les boîtiers de transistor bipolaires) et TO220. Le premier est limité à 100mA en sortie, tandis que le régulateur en boîtier TO220 est limité généralement à 1A. Les 7805 en boîtier TO220 ont tendance à chauffer mais cela est tout à fait normal. Ce genre de boîtier peut d'ailleurs être muni d'un dissipateur. Voici le brochage de ce composant :</paragraph>
    <image>
      <link type="img">D:\Documents\Cours Progworld\pic\images\7805.gif</link>
      <legend>&lt;br&gt;&lt;br&gt;D:\Documents\Cours Progworld\pic\images\7805.gif</legend>
    </image>
    <paragraph>Enfin, nous avons deux composants indispensablees : un condensateur non polarisé de 100nF et un condensateur polarisé de quelques dizaines de nano Farads. Le premier condensateur sert à éviter que la tension de sortie oscille. Ce condensateur doit être placé le plus prêt possible de la sortie du 7805. Le codensateur polarisé constitue quant à lui une réserve d'énergie. Cette énergie sera délivrée si la charge demande brusquement du courant. (un moteur qui démarre par exemple)</paragraph>
    <paragraph>Enfin, il est toujours pratique d'ajouter une LED en sortie pour savoir si une tension existe.</paragraph>
  </section>
  <section title="Le modèle de programmation et les mémoires internes">
    <paragraph>Nous partons du principe que vous possédez quelques bases sur les processeurs et les microcontrôleurs. Si vous bloquez sur une notion, n'hésitez pas à consulter les cours de systèmes numériques ou à écrire à l'auteur du cours ! Entrons maintenant à l'intérieur du microcontrôleur.</paragraph>
    <paragraph>Mais tout d'abord qu'est ce qu'un modèle de programmation ? C'est en fait l'ensemble des ressources à disposition du développeur. Dans le monde des processeurs et, par extension, dans le monde des microcontrôleurs, les ressources se matérialisent par :</paragraph>
    <paragraph>&lt;ul&gt;&lt;br&gt;&lt;li&gt;Les registres de calcul&lt;/li&gt;&lt;br&gt;&lt;li&gt;Les registres de configuration&lt;/li&gt;&lt;br&gt;&lt;li&gt;Les registres des périphériques&lt;/li&gt;&lt;br&gt;&lt;li&gt;Les différentes mémoires internes (RAM, ROM etc.)&lt;/li&gt;&lt;br&gt;&lt;ul&gt;</paragraph>
    <paragraph>A l'aide de toutes ces zones mémoires et de stockage, il est possible de faire effectuer au microcontrôleur des calculs, des transferts de données et de la communication avec le "monde extérieur", c'est à dire aux périphériques du composant. Regardons maintenant la structure interne du microcontrôleur.</paragraph>
    <image>
      <link type="img">D:\Documents\Cours Progworld\pic\images\structure.gif</link>
      <legend>Structure interne du PIC16F84. (documentation constructeur)&lt;br&gt;</legend>
    </image>
    <paragraph>Analysons un peu ce diagramme, qui se révèle très intéressant. D'une part, nous voyons les mémoires disponibles à l'intérieur du microcontrôleur :</paragraph>
    <paragraph>&lt;ul&gt;&lt;br&gt;&lt;li&gt;La mémoire Flash : 1k*14&lt;/li&gt;&lt;br&gt;&lt;li&gt;La mémoire RAM : 68*8&lt;/li&gt;&lt;br&gt;&lt;li&gt;La mémoire EEPROM : 64*8&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</paragraph>
    <paragraph>Ces différentes mémoires sont séparées en &lt;b&gt;deux blocs&lt;/b&gt; : d'une part &lt;b&gt;la mémoire programme&lt;/b&gt; et d'autre part &lt;b&gt;la mémoire données&lt;/b&gt;. Chaque bloc possède son propre bus, il est donc possible d'accéder à chaque bloc en même temps durant un cycle d'horloge. Regardons d'un peu plus près le contenu de ses deux blocs.</paragraph>
    <paragraph>&lt;font size="5" color="#0000FF"&gt;1. Le bloc mémoire programme&lt;/font&gt;&lt;br&gt;</paragraph>
    <paragraph>La mémoire programme sera utilisée pour stocker le programme du développeur. Une fois le code assembleur assemblé, il est stocké dans cette mémoire reprogrammable à technologie FLASH. Une mémoire FLASH peut être effacée puis programmée environ 10 000 fois. L'effacement de la FLASH est obligatoire avant toute procédure de programmation. La FLASH est organisée par mots fixes de 14 bits. Chaque instruction de programme, une fois assemblée, sera donc de 14 bits. La mémoire FLASH garde ses données même après un Reset et en l'absence d'alimentation. Le programmeur dispose d'une mémoire maximale de 1024 mots pour écrire son programme. C'est peu, mais c'est un petit microcontrôleur dont le but est d'apporter une intelligence localisée à un système. Donc cette taille sera suffisante pour nos applications. Voici le diagramme de ce bloc :</paragraph>
    <image>
      <link type="img">D:\Documents\Cours Progworld\pic\images\program_area.gif</link>
      <legend>La zone mémoire programme du PIC16F84.&lt;br&gt;</legend>
    </image>
    <paragraph>Le PIC possède un compteur interne de 13 bits, il a donc un espace mémoire de 8k*14 bits. Or, nous avons dit précédemment que seulement 1k*14 étaient utilisables, situés dans la partie basse de l'espace mémoire de l'adresse 0x0000 à 0x03FF. Que se passe-t-il alors si le programmeur veut accéder à une adresse supérieure ? En réalité, les 8 zones mémoires de 1k*14 bits chacune sont les mêmes. Les premiers 1k*14 bits sont physiquement implantés tandis qu'un accès aux autres adresses se verra renvoyé dans ce premier espace mémoire. Ainsi, les adresses 0x20, 0x420, 0x820, 0xC20, 0x1020, 0x1420, 0x1820, et 0x1C20 sont les mêmes. </paragraph>
    <paragraph>&lt;b&gt;Le PC :&lt;/b&gt; C'est le Program Counter. Ce registre stocke l'adresse courante du programme. Cette adresse s'incrémente donc au fur et à mesure que le programme se déroule. Sa taille est de 13 bits, c'est à dire la taille de l'espace mémoire.</paragraph>
    <paragraph>&lt;b&gt;Le Stack : &lt;/b&gt;Un autre élément fait partie de ce bloc mémoire : le stack, représenté au dessus de la zone mémoire programme sur le diagramme. Cette zone, appelée pile en français, sert à stocker les adresses programmes lors de l'appel à des sous programmes. Les sous programmes peuvent être appelés directement par le code assembleur (instruction CALL) ou lors d'une interruption. Le contenu du PC est alors copié dans le stack, qui s'empile au fur et à mesure des appels. Le PIC est donc limité à 8 sous programmes consécutifs. Si plus d'appels sont provoqués, alors la pile se remplit en repartant du Level 1.</paragraph>
    <paragraph>&lt;font size="5" color="#0000FF"&gt;2. Le bloc mémoire données&lt;/font&gt;&lt;br&gt;</paragraph>
    <paragraph>Le bloc mémoire données se distingue par plusieurs sous parties. Voici le schéma tel qu'il apparait dans la documentation constructeur :</paragraph>
    <image>
      <link type="img">F:\Documents\Cours Progworld\pic\images\cours1_data_area.gif</link>
      <legend>&lt;br&gt;</legend>
    </image>
    <paragraph>Ce bloc est séparé en deux parties : d'un côté la RAM, de 0x0C à 0x4F et de l'autre les registres, de 0x00à 0x0B. Tous ces espaces mémoires ont une longueur de 8 bits.</paragraph>
    <paragraph>&lt;b&gt;La mémoire RAM&lt;/b&gt; : elle servira à stocker les variables utilisées par le programme. Rien de spécial à signifier, hormis que, à l'instar des autres RAM, cette mémoire pert ses données une fois l'alimentation coupée. Cette zone mémoire est appelée GPR, Registres à Usage Général. L'implantation physique de la RAM va de l'adresse 0x0C à 0x4F. Or, nous voyons que la mémoire données est séparée en deux "bank", la bank 0 et la bank 1. La RAM phyqique est située dans la bank 0 mais une version mappée se trouve en bank 1 de l'adresse 0x8C à 0xCF. C'est la même logique que pour la mémoire programme, un accès à la RAM dans la bank 1 revient à accéder aux même zones mémoires dans la bank 0.</paragraph>
    <paragraph>&lt;b&gt;le SFR : &lt;/b&gt; pour Special Function Register. Cette partie vous est familière si vous avez déjà travaillé sur des processeurs ou des microcontrôleurs. Il s'agit des zones mémoires (registres) dédiés aux calculs, aux transferts de données et au paramétrage des périphériques et du microcontrôleur. Il s'agit de la tour de contrôle du microcontrôleur. Là encore, une partie du SFR se trouve en bank 0 tandis que l'autre se situe en bank 1. Cependant, les registres &lt;u&gt;ne sont pas toujours les mêmes&lt;/u&gt; dans les deux banks, contrairement à la RAM. Nous n'allons pas décrire les registres un par un, la documentation constructeur est sufisamment explicite. Nous vous conseillons de l'imprimer et de l'avoir à côté de vous lorsque vous programmez ! Nénamoins, nous y reviendrons en temps voulu.</paragraph>
    <paragraph>Enfin, vient la mémoire EEPROM. Cette mémoire non volatile sert à mémoriser des variables. Celles ci seront gardées en mémoire même en l'absence d'alimentation. Ce genre de petite mémoire est très utile pour sauvegarder des préférences utilisateurs par exemples, ou des données en provenance de capteurs etc. L'accès se gère à partir de registres du SFR, elle n'est pas directement mappée dans l'espace mémoire.</paragraph>
    <note title="Remarque" img="http://www.programmationworld.com/site/images/rmq.gif">L'accès au bloc mémoire données peut se faire soit en changeant de "bank", soit par l'adresse effective de l'octet visé.</note>
  </section>
  <section title="Autres fonctionalités">
    <paragraph>Le PIC 16F84 n'est pas énorme mais possède quelques fonctionalités propres au monde des microcontrôleurs.</paragraph>
    <paragraph>Notons par exemple l'existance d'un seul et unique timer (ou compteur). Ce timer est de 8 bits (il peut donc compter de 0 à 255) et possède un prédiviseur de fréquence paramétrable par 2,4,8,16,32,64,128,256.</paragraph>
    <paragraph>Le PIC 16F84 possède 4 sources d'interruptions :&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;Interruption matérielle par la broche RB0&lt;/li&gt;&lt;br&gt;&lt;li&gt;Interruption logicielle par dépassement du timer&lt;/li&gt;&lt;br&gt;&lt;li&gt;Interruption matérielle par changement d'état des broches RB[4..7]&lt;/li&gt;&lt;br&gt;&lt;li&gt;Fin d'écriture dans la mémoire EEPROM&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</paragraph>
    <paragraph>Il existe un Watch Dog, ou chien de garde en français. Celui-ci utilise le timer lorqu'il est activé. Le timer n'est alors plus disponible pour effectuer d'autres tâches. Un chien de garde permet de sécurisé tout ou une partie du code. Il peut servir comme "time out" ou de protection en cas de plantage. Cela est utile pour les systèmes critiques par exemple, qui ne peuvent se permettre de planter.</paragraph>
    <paragraph>Le PIC 16F84 est équipé d'un Power-on-Reset. Cette fonctionalité provoque un reset lors de la mise sous tension (Lorsque Vdd passe de 0V à 5V). Le programme démarre ainsi dès que le composant est mis sous tension. Cela évite certains problèmes et épargne l'utilisation d'un circuit RC externe sur la broche MCLR.</paragraph>
    <paragraph>Enfin, notons qu'il existe à l'heure actuelle deux versions majeurs du 16F84 : le 16F84 "tout court", qui permet d'utiliser un quartz de 10MHz maximum et le 16F84A qui permet d'aller jusqu'à 20MHz. Le prix des deux version est sensiblement le même, donc autant acheter que du 16F84A qui se trouve maintenant un peu partout.</paragraph>
  </section>
  <section title="Téléchargements">
    <paragraph>&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href="downloads/16F84A.pdf"&gt;16F84A.pdf&lt;/a&gt; : la documentation constructeur, à posséder obligatoirement et à imprimer !&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href="downloads/78xx.pdf"&gt;78xx.pdf&lt;/a&gt; : la documentation du régulateur de tension utilisé sur cette page&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;</paragraph>
  </section>
</document>